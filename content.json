{"posts":[{"title":"","text":"title： 一些奇怪的tip下面是我整理的平时碰到的一些奇怪的错误总结的奇怪的提示，持续更新（哈哈 使用排序/查找 lower_bound如果没有找到大于等于的值返回a.end() lower_bound返回值是一个迭代器，*解值，-begin()返回序列pos sort排序左闭右开区间 优先级1cout &lt;&lt; (x ^ pre) &lt;&lt; ' '; 这里一定要加括号否则报错 关于内存分配 数组的初始化时间复杂度是 O(1) ，vector是O(n) vector 比 vector能开更大的数组,因为int的内存比long long 小 vector因为某些神奇原因会导致程序变慢 vecotr如果你需要push进东西的话,可以提前reserve(n) 本质上就是一次 内存分配，复杂度是 O(1)（严格来说是 O(n) 的内存分配，但没有逐元素初始化）用 reserve 可以一次性分配好空间，避免多次扩容和数据搬迁 在大数据量输出场景下，**endl **会因为强制刷新导致超时。用'\\n' 更快,因为endl 实时输出 O2优化不开优化可能 TLE 的典型情况： 用 vector&lt;bool&gt; 做标记数组。 大循环里频繁调用小函数。 重复计算没有手动消除。 大量输出用 endl。 使用 STL 的慢接口（如 .at()）。 大数组访问模式不友好。 在比赛里，默认开 -O2 是必须的，它能帮你自动解决很多卡常问题。 编译器选项中添加：g++ main.cpp -o main -O2 -std=c++23 ranges12345678910111213ranges::sort(a);ranges::reverse(a);if (ranges::find(a, x) != a.end()) { // 找到了}int mx = std::ranges::max(a);int mn = std::ranges::min(a);auto it = ranges::lower_bound(a, x); 手动实现向上/下取整向下取整（数学 floor）1234long long floordiv(long long a, long long b) { if (a &gt;= 0) return a / b; return - ((-a + b - 1) / b);} 向上取整（数学 ceil）1234long long ceildiv(long long a, long long b) { if (a &gt;= 0) return (a + b - 1) / b; return - ((-a) / b);} 我的若只错误 变量名重复，按照顺序命名a，b，c，d","link":"/2025/12/23/Odd_Problem/"},{"title":"","text":"A题意求$X$翻倍$Y$次的结果 是翻倍不是求幂QAQ 思路位运算或者$pow()$ 代码1234567void solve(){ int x, y; cin &gt;&gt; x &gt;&gt; y; // cout &lt;&lt; x * pow(2, y) &lt;&lt; endl; while (y --) x &lt;&lt;= 1; // 位运算 cout &lt;&lt; x &lt;&lt; endl;} B题意给定长度为$N$数组, 求最大的三个值的编号 思路结构体或者$pair$存储 代码12345678910void solve(){ int n; cin &gt;&gt; n; vector&lt;PII&gt; a(n + 1); for (int i = 1; i &lt;= n; i ++) { cin &gt;&gt; a[i].first; a[i].second = i; //注意编码 } sort(a.begin() + 1, a.end()); //注意条件 cout &lt;&lt; a[1].second &lt;&lt; ' ' &lt;&lt; a[2].second &lt;&lt; ' ' &lt;&lt; a[3].second &lt;&lt; endl;} 关于排序 重载$cmp$最严谨写法 1234sort(a.begin() + 1, a.end(), [](PII x, PII y) { if (x.first != y.first) return x.first &lt; y.first; else return x.second &lt; y.second; //根据具体题目}); 本题数组值都不一样, 重载时候不会出现键不同的情况, 不写分类不会报错 $sort$本身对$pair$排序的时候先比较键, 后比较值 逆序排序写法 12345678// 1-based排序sort(a.begin() + 1, a.end(), greater&lt;int&gt;());sort(a.begin() + 1, a.end());reverse(a.begin() + 1, a.end());//仅0-based排序可用sort(v.rbegin(), v.rend()); C题意给定一个数组，取任意的$x$，将$1 \\leq i \\leq N$ 的内所有整数 $i$中满足$ (i + x) $ 除以 $2W$的余数小于$ W $的数加上,求最小总和 思路最简单的思路是枚举$x$, 然后求出总和比较, 注意到因为取模操作, $x &lt; 2W$即可,时间复杂度$O(T \\cdot W \\cdot N)$ 继续优化, 我们注意到取模操作会让范围都落在$[0, 2W - 1]$上, 且$$(i + x) % 2W = (i + x + 2W) % 2W$$将下标离散化为$[0, 2W - 1]$上, 问题转化为求$2W$长的数组中长度为$W$的最小连续子段和,用滑动窗口, 时间复杂度为$O(T \\cdot (W + N))$ 代码12345678910111213141516171819202122232425void solve(){ int n, w; cin &gt;&gt; n &gt;&gt; w; vector &lt;int&gt; a(n + 1); vector &lt;int&gt; b(2 * w); int m = 2 * w; for (int i = 1; i &lt;= n; i ++) { cin &gt;&gt; a[i]; b[i % m] += a[i]; } int mn, cur, pas; mn = accumulate(b.begin(),b.begin() + w, 0LL); pas = mn; for (int i = 1; i &lt; 2 * w; i ++) { cur = pas - b[i - 1] + b[(i + w - 1) % m]; mn = min (cur, mn); pas = cur; } cout &lt;&lt; mn &lt;&lt; endl;} D题意给定长度为$N$的数组$A$, $Q$次查询, 给定$X$, $Y$, 求值$ans$使得[$X$, $ans$]之间存在$Y$个不在数组中的数 思路首先如果可以确定$ans$的值的情况下, 令[$X$, $ans$]之间$ \\neq A_i$的值的个数为$an$, 如果我们知道$A$在[$X$, $ans$]的第一个下标$l$和最后一个下标$r$, 那么有$$an = ans - x + 1 - (r - l + 1)$$ 要求$an = y$. 那么最简单的想法, 二分答案$ans$, 预处理超过$A_{max}$的情况, 数组$A$的最大范围$m=1e9$, 时间复杂度$O(mlogm)$, 需要优化 我们注意到, $ans$不可能是$A_i$, 我们的$an$遇到$A_i$就会改变, 根据上面表达式, 与数组$A$相关的其实只有$r$和$l$, 所以我们可以选择枚举$ans$的范围, 设$r$是第一个大于$ans$的值, 此时公式$$an = A_r - x - (r - l)$$求满足$an \\geq ans$的最小$r$即可, 最终答案$$ ans = x + y -1 + (r - l)$$时间复杂度$O(nlogn)$ 代码123456789101112131415161718192021222324252627282930313233343536void solve(){ int n, q; cin &gt;&gt; n &gt;&gt; q; vector&lt;int&gt; a (n + 1); for (int i = 1; i &lt;= n; i ++) { cin &gt;&gt; a[i]; } ranges :: sort (a); int x, y; while (q --) { cin &gt;&gt; x &gt;&gt; y; int l = lower_bound(a.begin() + 1, a.end(), x) - a.begin(); if (l &gt; n) { cout &lt;&lt; x + y - 1 &lt;&lt; endl; continue; } int mn = l; int r = n; while (l &lt;= r) { int mid = l + (r - l) / 2; int an = a[mid] - x - (mid - mn); if (an &lt; y) { l = mid + 1; } else { r = mid - 1; } } if (l &gt; n) { cout &lt;&lt; x + y - 1 + (n - mn + 1) &lt;&lt; endl; } else { cout &lt;&lt; x + y - 1 + (l - mn) &lt;&lt; endl; } }}","link":"/2026/01/11/AtCoder%20Beginner%20Contest%20440%E9%A2%98%E8%A7%A3/"}],"tags":[],"categories":[],"pages":[]}